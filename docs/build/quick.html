<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Start · SDDP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SDDP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="quick.html">Quick Start</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="quick.html">Quick Start</a></li></ul><a class="edit-page" href="https://github.com/odow/SDDP.jl/tree/fc2d92f6d1f0acd9331b7225d3fdfa4e5df14961/docs/src/quick.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Quick Start</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Quick-Start-1" href="#Quick-Start-1">Quick Start</a></h1><h3><a class="nav-anchor" id="Initialising-the-model-object-1" href="#Initialising-the-model-object-1">Initialising the model object</a></h3><p>The first step is to initialise the SDDP model object. We do this using the following syntax:</p><p>If we have more than one markov state:</p><pre><code class="language-julia">m = SDDPModel([;kwargs...]) do sp, stage, markov_state

    # Stage problem definition where `sp` is a `JuMP.Model`object,

end</code></pre><p>Otherwise if we have a single markov state</p><pre><code class="language-julia">m = SDDPModel([;kwargs...]) do sp, stage

  # Stage problem definition

end</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.SDDPModel" href="#SDDP.SDDPModel"><code>SDDP.SDDPModel</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SDDPModel(;kwargs...) do ...

end</code></pre><p><strong>Description</strong></p><p>This function constructs an SDDPModel.</p><p><strong>Required Keyword arguments</strong></p><ul><li><p><code>stages::Int</code></p></li></ul><p>The number of stages in the problem. A stage is defined as each step in time at  which a decion can be made. Defaults to <code>1</code>.</p><ul><li><p><code>objective_bound::Float64</code></p></li><li><p><code>solver::MathProgBase.AbstractMathProgSolver</code></p></li></ul><p><strong>Optional Keyword arguments</strong></p><ul><li><p><code>cut_oracle</code></p></li><li><p><code>risk_measure</code></p></li><li><p><code>noise_probability</code></p></li><li><p><code>markov_transition</code></p></li></ul><p><strong>Returns</strong></p><pre><code class="language-none">* `m`: the `SDDPModel`</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/tree/fc2d92f6d1f0acd9331b7225d3fdfa4e5df14961/src/SDDP.jl#L50-L76">source</a><br/></section><h3><a class="nav-anchor" id="Solve-1" href="#Solve-1">Solve</a></h3><p>To solve the SDDP model <code>m</code> we use <code>status = solve(m::SDDPModel; kwargs...)</code>. This accepts a number of keyword arguments to control the solution process.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.solve" href="#JuMP.solve"><code>JuMP.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">solve(m::SDDPModel; kwargs...)</code></pre><p><strong>Description</strong></p><p>Solve the SDDPModel <code>m</code> using SDDP. Accepts a number of keyword arguments to control the solution process.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>m</code>: the SDDPModel to solve</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>max_iterations::Int</code>:  The maximum number of cuts to add to a single stage problem before terminating.  Defaults to <code>10</code>.</p></li><li><p><code>time_limit::Real</code>:  The maximum number of seconds (in real time) to compute for before termination.  Defaults to <code>Inf</code>.</p></li><li><p><code>simulation::MonteCarloSimulation</code>:  We control the behaviour of the policy simulation phase of the algorithm using  the <code>MonteCarloSimulation(;kwargs...)</code> constructor. This just groups a  series of related keyword arguments. The keywords are</p><ul><li><p><code>frequency::Int</code></p></li></ul><p>The frequency (by iteration) with which to run the policy simulation phase of  the algorithm in order to construct a statistical bound for the policy. Defaults  to <code>0</code> (never run).</p><ul><li><p><code>min::Float64</code></p></li></ul><p>Minimum number of simulations to conduct before constructing a confidence interval  for the bound. Defaults to <code>20</code>.</p><ul><li><p><code>step::Float64</code></p></li></ul><p>Number of additional simulations to conduct before constructing a new confidence  interval for the bound. Defaults to <code>1</code>.</p><ul><li><p><code>max::Float64</code></p></li></ul><p>Maximum number of simulations to conduct in the policy simulation phase. Defaults  to <code>min</code>.</p><ul><li><p><code>confidence::Float64</code></p></li></ul><p>Confidence level of the confidence interval. Defaults to <code>0.95</code> (95% CI).</p><ul><li><p><code>termination::Bool</code></p></li></ul><p>Whether to terminate the solution algorithm with the status <code>:converged</code> if the  deterministic bound is with in the statistical bound after <code>max</code> simulations.  Defaults to <code>false</code>.</p></li><li><p><code>bound_convergence</code>:  We may also wish to terminate the algorithm if the deterministic bound stalls  for a specified number of iterations (regardless of whether the policy has  converged). This can be controlled by the <code>BoundConvergence(;kwargs...)</code>  constructor. It has the following keywords:</p><ul><li><p><code>iterations::Int</code></p></li></ul><p>Terminate if the maximum deviation in the deterministic bound from the mean  over the last <code>iterations</code> number of iterations is less than <code>rtol</code> (in  relative terms) or <code>atol</code> (in absolute terms).</p><ul><li><p><code>rtol::Float64</code></p></li></ul><p>Maximum allowed relative deviation from the mean.  Defaults to <code>0.0</code></p><ul><li><p><code>atol::Float64</code></p></li></ul><p>Maximum allowed absolute deviation from the mean.  Defaults to <code>0.0</code></p></li><li><p><code>cut_selection_frequency::Int</code>:  Frequency (by iteration) with which to rebuild subproblems using a subset of  cuts. Frequent cut selection (i.e. <code>cut_selection_frequency</code> is small) reduces  the size of the subproblems that are solved, but incurrs the overhead of rebuilding  the subproblems. However, infrequent cut selection (i.e.  <code>cut_selection_frequency</code> is large) allows the subproblems to grow large (many  constraints) leading to an increase in the solve time of individual subproblems.  Defaults to <code>0</code> (never run).</p></li><li><p><code>print_level::Int</code>:   0 - off: nothing logged to screen (still written to log file if specified).   1 - on: solve iterations written to screen.   Defaults to <code>1</code></p></li><li><p><code>log_file::String</code>:  Relative filename to write the log to disk. Defaults to <code>&quot;&quot;</code> (no log written)</p></li><li><p><code>solve_type</code>:  One of</p><ul><li><p><code>Asyncronous()</code> - solve using a parallelised algorithm</p></li><li><p><code>Serial()</code> - solve using a serial algorithm</p></li></ul><p>Default chooses automatically based on the number of available processors.</p></li><li><p><code>reduce_memory_footprint::Bool</code>:  Implements the idea proposed in https://github.com/JuliaOpt/JuMP.jl/issues/969#issuecomment-282191105  to reduce the memory consumption when running SDDP. This is an issue if you  wish to save the model <code>m</code> to disk since it discards important information.  Defaults to <code>false</code>.</p></li><li><p><code>cut_output_file::String</code>:  Relative filename to write discovered cuts to disk. Defaults to <code>&quot;&quot;</code> (no cuts written)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>status::Symbol</code>:  Reason for termination. One of</p><ul><li><p><code>:solving</code></p></li><li><p><code>:interrupted</code></p></li><li><p><code>:converged</code></p></li><li><p><code>:max_iterations</code></p></li><li><p><code>:bound_convergence</code></p></li><li><p><code>:time_limit</code></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/tree/fc2d92f6d1f0acd9331b7225d3fdfa4e5df14961/src/SDDP.jl#L338-L430">source</a><br/></section><h3><a class="nav-anchor" id="Simulate-1" href="#Simulate-1">Simulate</a></h3><h3><a class="nav-anchor" id="Visualise-1" href="#Visualise-1">Visualise</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.@visualise" href="#SDDP.@visualise"><code>SDDP.@visualise</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@visualise(results, replication, stage, begin
	... plot definitions ...
end)</code></pre><p><strong>Description</strong></p><pre><code class="language-none">Plot everything using interactive javascript. This will launch an HTML page
to explore.</code></pre><p><strong>Usage</strong></p><pre><code class="language-none">    `@visualise(results, i, t, begin
        ... one line for each plot ...
    end)`

where results is the vector of result dictionaries from simulate(), i is the
simulation index (1:length(results)), and t is the stage index (1:T).

Each plot line gets transformed into an anonymous function
    (results, i, t) -&gt; ... plot line ...
so can be any valid Julia syntax that uses results, i, or t as an argument.

After the plot definition, keyword arguments can be used (in parenthesises):
    `title`       - set the title of the plot
    `ylabel`      - set the yaxis label
    `xlabel`      - set the xaxis label
    `interpolate` - interpolate lines between stages. Defaults to &quot;linear&quot;
    see https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md
        #line_interpolate for all options</code></pre><p><strong>Results Object</strong></p><pre><code class="language-none">`results::Vector{Dict{Symbol, Any}}` is a vector of dictionaries where each
dictionary corresponds to one simulation (therefore there will be
`N = length(results)` lines plotted in each graph).</code></pre></div><a class="source-link" target="_blank" href="https://github.com/odow/SDDP.jl/tree/fc2d92f6d1f0acd9331b7225d3fdfa4e5df14961/src/visualiser/visualise.jl#L55-L91">source</a><br/></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a></footer></article></body></html>
